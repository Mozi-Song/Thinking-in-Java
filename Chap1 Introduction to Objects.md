第一章 对象入门
======
### 1. OOP语言抽象模型与以往的语言模型最不同的地方在哪里？ P1
早期的汇编语言以及后来的许多“命令式”语言（如FORTRAN、BASIC和C）立足于机器模型，要求程序员们将思维从问题空间转化到方案空间进行编程。而OOP语言允许程序员直接描述问题空间，即根据问题而非方案来描述问题，是一种更加灵活、强大的抽象方法。
### 2. Java设定边界的三个显式关键字及一个默认关键字的内涵是什么？P5
public：任何人均可使用后续定义。 

private：只有类内的函数可以使用。 

protected:只有类内和继承的类的函数可以使用。 

默认：只有同一个包内的类可以使用。

| Modifier      | Class        |Package       |Subclass      |World         |
| ------------- |------------- |------------- |------------- |-------------:|
| public        | Y | Y | Y | Y | 
| protected     | Y | Y | Y | N |
| no modifier   | Y | Y | N | N |
| private       | Y | N | N | N |


### 3. 早期和后期绑定的意义？ P11 
非OOP语言的编译器使用早期绑定：编译器发出函数调用后，链接器将对该调用进行分析，将其指向要执行的代码的绝对位置。OOP语言则使用后期绑定：编译器只负责检查函数的签名，实际调用的代码要到运行时，使用对象中保存的信息才能确定函数体所在的地址。
### 4. Upcasting的涵义？　P11-12
### 5. 抽象类、抽象方法、接口的涵义？ P12-13
### 6. 单根结构的涵义，与C++相比的优点
=====P16
### 疑惑：

P6.由于继承实在太重要，所以在面向对象的程序设计中它经常都被重点强调。也正是由于这个原因，作为新加入这一领域的程序员，或许早便先入为主地认为“继承应当随处可见”。不过沿这一思路产生的设计将是非常笨拙的，会大大增加程序的复杂程度。相反，新建类的时候，首先应考虑“创作”出新对象；这样显得更加简单和灵活。利用对象的创作，我们的设计可保持清爽。以后，当你需要用到继承的时候，就会清楚地认识到这一点。

P13.interface接口关键字将抽象类的概念更延伸了一步，它完全禁止了任何函数定义。接口是一种相当有效和常用的工具，因为它能将接口同具体的实现代码完美分隔开。另
外，如果愿意，亦可将多个接口都合并到一起，只是不能从多个普通类或抽象类中继承。
*应该何时使用interface,何时使用抽象类？

P13.若在堆栈或者静态存储空间里创建一个对象，编译器就能正确知道对象的存在时间有多长，到时会自动破坏或清除它。然而假如在一个堆里创建，编译器就没法子知道它的
准确生存时间。在象C++这样的语言里，必须在程序中硬性规定何时破坏一个对象。但假如操作不当，就可能造成内存漏洞的出现（出现一片谁都用不了的内存区域），这是C++
程序最令人头痛的问题之一。为此Java采用了一种名为垃圾收集器的机制，可自动探测出一个不再使用的对象，并自动将其清除。
*为什么放在堆栈上编译器就知道对象的存在时间，而放在堆上就不行？

p15.另一种方案（就象C++那样）是我们不能保证所有东西都属于相同的基类型从。向后兼容的角度看，这一方案可与C模型更好地配合，而且可以认为它的限制更少一些。但假如我们想进行纯粹的面向对象编程，那么必须构建自己的结构，以期获得与内建到其他OOP语言里的同样的便利。此时，便需要添加我们要用到的各种新类库，还要使用另一些不兼容的接口。理所当然地，这也需要付出额外的精力，使新接口与自己的设计方案配合（可能还需要多重继承）。为得到C++额外的“灵活性”，付出这样的代价值得吗？

采用一个单根结构，再加上所有对象都在内存堆中创建，便可极大简化参数的传递（这在C++里可是一个非常让人头痛的的概念）。

由于运行时类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要（比如在违例控制的时候）；而且也能在程序设计中获得更大的灵活性。
